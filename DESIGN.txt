1.

src
    entities
        data
            Node
            Session
        interface
            Node
            Session
        userInterface
            Node
            Session
    interfaces
        sessionManager XXX
    tech
        fileSystem
        nestedObj XXX object-path(npm) OOO
    resource
        appSession
        DB
        DOM
        DOMRefs
    App



2.

src
    entities
        static
            NodeData
                id: uuid
                key: String
                value: String?
                parent: Node
                relations: Array: {tie: String, node: Node}
            SessionData
                name
                root: Node
                seed: Node
                lastCopiedNode: Node
        visual
            Node
                DOM
                depth: Int
                selected: Bool
                grown: Bool
                filter: String
                render()
                grow()
                shrink()
                plant()
                
            Session
        final
            Node
            
                mirrorLink()
                isLink()
                getPath()
                getPathString()

                
                /*이건 그냥 UserAction에 떠넘기는게 맞는것같다.
                Node 객체는 이 정도 추상적인 인터페이스까진 제공 안해도 될것 같다.
                
                이건 UI 만들면서 하나씩 추가해도 된다.
                moveUp()
                moveDown()
                depthUp()
                depthDown()
                copy()
                paste()
                toggleGrow()
                setFilter()
                setKey()
                setValue()
                addTie()
                deleteTie()
                
                */
            Session
                
    interfaces
        sessionManager XXX
    tech
        fileSystem
        nestedObj XXX object-path(npm) OOO
    resource
        appSession
        DB
        DOM
        DOMRefs
    App



3.
src
    entity
        static
            NodeData
                id: uuid
                key: String
                value: String?
                parent: Node
                relations: Array: {tie: String, node: Node}
            SessionData
                name
                root: Node
                seed: Node
                copiedNode: Node
        visual
            Node
                DOM
                depth: Int
                selected: Bool
                grown: Bool
                filter: String
                render()
                grow()
                shrink()
        auto
            Node
                constructor(nodeData, nodeVisual)
                mirrorLink()
                isLink()
                getPath()
                getPathString()
            Session
    tech
        fileSystem
        nestedObj XXX  object-path(npm) OOO
    resource
        appSession: SessionData
        DB
        DOM
        DOMRefs
    natural
        userActions
        init
    App




...
entity
    data
    logic
    facade

Node
    data
        id
        key
        value
        parent
    logic
        isLink()
        render()
            this.data.key 어쩌구
            
    visual
        if (this.logic.isLink()) this.visual.DOM.querySelector("#key").style.color = "skyblue"

userActions
    db.update(node.data.id, node.data)



4.
src
    entity
        static
            NodeData: class? interface? class with type validator???
                id: uuid
                key: String
                value: String?
                origin: NodeData.id(외래키)
                relations: Array of {tie: String, node: NodeData.id(외래키)}
            SessionData
                name: String
                srcRootData: RootData
                modifiedNodes: Array of NodeData that are changed by NodeView instances
                nodeViews: Array of NodeView
                rootNode: Node
                seedNode: Node
                copiedNode: Node
                adress: Array of path, from rootNode to thisNode
                history: Array of path, every nodes visited in order
            RootData: sql.js DB
                root: NodeData or NodeData.id
                nodes: NodeData
            TreeData: Array of NodeView(serialized)
            DocumentData
        model
            NodeModel extends NodeData
                constructor(data)
                mirrorLink()
                isLink()
                getPath()
                getPathString()
            DocumentModel
        view
            NodeView extends NodeModel
                constructor(data, visual)
                data
                DOM
                selected: Bool
                grown: Bool
                filter: String //filter relations to show by their ties
                render()
                    render its DOM by its key, value, parent, relations, selected, grown, and filter
                grow()
                    this.grown = false
                    this.render()
                shrink()
                    this.grown = true
                    this.render()
                copy()
                paste()
    tech
        fileSystem
        nestedObj XXX  object-path(npm) OOO
        sql.js
        dbSystem (sql.js 추상화 인터페이스)
				    class DB
						class Table
	              where()
		            equals()
								
            function validate(db, sql, options)
    resource
        appSession: SessionData
        browserDB
            initData
                lastRootDB
                lastSeed
                lastTree: TreeData
        DOM
        DOMRefs
    natural
        userActions
            saveChanges()
                appSession.editor.modifiedNodes foreach {
                    appSession.srcRootData 에 저장
                    fileSystem 활용하여 유저의 스토리지에 영구 저장
                }
        init
    App



SQL로 노드액션, 유저액션 구현해보기. 

Node.grow() 
let relations = SELECT relations FROM allNodes WHERE id EQUALS ${this.id}
relations.forEach(r => 

let relatedNodeData = SELECT * FROM allNodes WHERE r.id

)

MVC 패턴에 대한 나의 생각:
컨트롤러가 굳이 필요할까.
간단한 엔티티라면 모델 수준의 추상화는 클래스의 메소드명으로 충분하다.
그 안에 들어있는 로직이 컨트롤러나 다름없다.
만약 static 데이터에 대해 매우 복잡한 조작이 이루어진다면 컨트롤러가 따로 필요할 것이다.
그러나 그 정도로 복잡한 조작을 해야한다면, 애초에 tech를 잘못 선택했다고 봐야할듯.
그리고 그런 복잡한 조작은 interface 계층에서 진작 추상화하는걸로.




할일
1. sql.js 이용해보기
2. nestedObj 퇴역
3. 모듈 재정의


sql.js 안되면 브라우저 업데이트 해볼것